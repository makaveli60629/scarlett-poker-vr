<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>POKER VR MASTER - 1.8.5</title>
    <style> body { margin: 0; background-color: #000; overflow: hidden; } </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js';

        // 1. DATA & TEXTURES
        let stats = JSON.parse(localStorage.getItem('poker_master_save')) || { chips: 500, lastDaily: 0 };
        const save = () => localStorage.setItem('poker_master_save', JSON.stringify(stats));
        
        const texLoader = new THREE.TextureLoader();
        const path = 'assets/textures/';
        const tex = {
            logo: texLoader.load(path + 'brand_logo.jpg'),
            brick: texLoader.load(path + 'brickwall.jpg'),
            carpet: texLoader.load(path + 'lobby_carpet.jpg'),
            felt: texLoader.load(path + 'table_felt_green.jpg'),
            claim: texLoader.load(path + 'dailyclaim.jpg')
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 2.5));
        const cameraRig = new THREE.Group();
        cameraRig.add(camera);
        scene.add(cameraRig);

        // 2. THE LOBBY ENCLOSURE
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ map: tex.carpet }));
        floor.rotation.x = -Math.PI/2; scene.add(floor);

        const lobbySize = 25;
        const wallMat = new THREE.MeshStandardMaterial({ map: tex.brick });
        for(let i=0; i<4; i++) {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(lobbySize, 10, 0.5), wallMat);
            const angle = (Math.PI/2) * i;
            wall.position.set(Math.sin(angle)*(lobbySize/2), 5, Math.cos(angle)*(lobbySize/2) - 5);
            wall.rotation.y = angle;
            scene.add(wall);
        }

        const table = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 0.4, 32), new THREE.MeshStandardMaterial({ map: tex.felt }));
        table.position.set(0, 0.8, -5); scene.add(table);
        
        const logo = new THREE.Mesh(new THREE.CircleGeometry(0.8, 32), new THREE.MeshBasicMaterial({ map: tex.logo, transparent: true }));
        logo.rotation.x = -Math.PI/2; logo.position.set(0, 1.21, -5); scene.add(logo);

        // 3. JUMBOTRON STATS
        const jumbCanvas = document.createElement('canvas');
        jumbCanvas.width = 1024; jumbCanvas.height = 512;
        const jumbCtx = jumbCanvas.getContext('2d');
        const jumbTex = new THREE.CanvasTexture(jumbCanvas);
        const jumb = new THREE.Mesh(new THREE.PlaneGeometry(8, 4), new THREE.MeshBasicMaterial({ map: jumbTex, transparent: true }));
        jumb.position.set(0, 8, -14); scene.add(jumb);

        function updateUI() {
            jumbCtx.clearRect(0,0,1024,512);
            jumbCtx.fillStyle = "rgba(0,0,0,0.85)"; jumbCtx.fillRect(0,0,1024,512);
            jumbCtx.strokeStyle = "#800080"; jumbCtx.lineWidth = 15; jumbCtx.strokeRect(10,10,1004,492);
            jumbCtx.fillStyle = "#fff"; jumbCtx.font = "bold 85px Arial";
            jumbCtx.fillText(`BALANCE: $${stats.chips}`, 100, 200);
            jumbCtx.fillText(`TIME: ${new Date().toLocaleTimeString()}`, 100, 380);
            jumbTex.needsUpdate = true;
        }
        setInterval(updateUI, 1000);

        // 4. 3D CARD MESHES
        function create3DCard(x, z) {
            const card = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.22, 0.005), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            card.position.set(x, 1.05, z); card.rotation.x = Math.PI/2;
            scene.add(card);
        }
        create3DCard(-0.2, -4.5); create3DCard(0.2, -4.5);

        // 5. OCULUS RIGHT-HAND CONTROLS
        const marker = new THREE.Mesh(new THREE.RingGeometry(0.3, 0.4, 32), new THREE.MeshBasicMaterial({ color: 0x00ffcc }));
        marker.rotation.x = -Math.PI/2; scene.add(marker);
        const controller = renderer.xr.getController(0); 
        cameraRig.add(controller);

        let turnCooldown = false;
        renderer.setAnimationLoop(() => {
            const session = renderer.xr.getSession();
            if (session) {
                for (const source of session.inputSources) {
                    if (source.handedness === 'right' && source.gamepad) {
                        const axes = source.gamepad.axes;
                        const buttons = source.gamepad.buttons;
                        // Snap Turn 45Â°
                        if (Math.abs(axes[2]) > 0.8 && !turnCooldown) {
                            cameraRig.rotation.y -= Math.sign(axes[2]) * (Math.PI/4);
                            turnCooldown = true; setTimeout(() => turnCooldown = false, 300);
                        }
                        // A Button Jump
                        if (buttons[4] && buttons[4].pressed && marker.visible) {
                            cameraRig.position.set(marker.position.x, 0, marker.position.z);
                        }
                    }
                }
            }
            // Raycaster for teleport
            const raycaster = new THREE.Raycaster();
            const m = new THREE.Matrix4().extractRotation(controller.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(m);
            const hits = raycaster.intersectObject(floor);
            if(hits.length > 0) { marker.position.copy(hits[0].point); marker.visible = true; }
            renderer.render(scene, camera);
        });
    </script>
</body>
</html>
