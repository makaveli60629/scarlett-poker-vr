<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>POKER VR MASTER - 1.6.1</title>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; font-family: sans-serif; }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js';

        // 1. ENGINE & PERSISTENT DATA
        let stats = JSON.parse(localStorage.getItem('poker_master_save')) || { chips: 500, lastDaily: 0 };
        const save = () => localStorage.setItem('poker_master_save', JSON.stringify(stats));

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setPixelRatio(1.5);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const cameraRig = new THREE.Group();
        cameraRig.add(camera);
        scene.add(cameraRig);

        // 2. WORLD ASSETS (Tables & Walls)
        scene.add(new THREE.AmbientLight(0xffffff, 1.2));
        scene.add(new THREE.GridHelper(200, 100, 0x00ffcc, 0x111111));

        function createPokerRoom(x, z, color, size, isLobby=false) {
            const group = new THREE.Group();
            const table = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 0.2, 32), new THREE.MeshStandardMaterial({color}));
            table.position.y = 0.8;
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 0.7, 16), new THREE.MeshBasicMaterial({color: 0x800080, transparent: true, opacity: 0.6}));
            leg.position.y = 0.35;
            group.add(table, leg);

            if(!isLobby) {
                const wallGeo = new THREE.BoxGeometry(size, 5, 0.2);
                const wallMat = new THREE.MeshStandardMaterial({color: 0x050505});
                for(let i=0; i<4; i++){
                    const wall = new THREE.Mesh(wallGeo, wallMat);
                    wall.rotation.y = (Math.PI/2) * i;
                    wall.position.set(Math.sin(wall.rotation.y)*size/2, 2.5, Math.cos(wall.rotation.y)*size/2);
                    group.add(wall);
                }
            }
            group.position.set(x, 0, z);
            scene.add(group);
            return group;
        }

        createPokerRoom(0, -5, 0x006400, 0, true); // Lobby
        createPokerRoom(0, -35, 0x440000, 18);    // High Stakes
        createPokerRoom(30, -15, 0x000044, 18);   // Low Stakes

        // 3. DAILY REWARD CHAIR
        const chair = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({color: 0x222222}));
        chair.position.set(-8, 0.5, -8);
        scene.add(chair);

        // 4. WRIST CONSOLE (Left Hand)
        const wristUI = new THREE.Group();
        const panel = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 0.15), new THREE.MeshBasicMaterial({color: 0x000000, transparent: true, opacity: 0.8, side: THREE.DoubleSide}));
        panel.rotation.x = -Math.PI/2;
        wristUI.add(panel);

        // Daily Button on Wrist
        const claimBtn = new THREE.Mesh(new THREE.PlaneGeometry(0.15, 0.05), new THREE.MeshBasicMaterial({color: 0x800080}));
        claimBtn.position.set(0, 0.01, 0.03);
        claimBtn.rotation.x = -Math.PI/2;
        wristUI.add(claimBtn);

        const controller2 = renderer.xr.getController(1); // Left
        controller2.add(wristUI);
        cameraRig.add(controller2);

        // 5. RIGHT HAND (Laser & Interaction)
        const controller1 = renderer.xr.getController(0); 
        const laser = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]), new THREE.LineBasicMaterial({color: 0x00ffcc}));
        laser.scale.z = 50;
        controller1.add(laser);
        cameraRig.add(controller1);

        const marker = new THREE.Mesh(new THREE.RingGeometry(0.3, 0.4, 32), new THREE.MeshBasicMaterial({color: 0x00ffcc}));
        marker.rotation.x = -Math.PI/2;
        scene.add(marker);

        // 6. LOGIC: TELEPORT & DAILY CLAIM
        const raycaster = new THREE.Raycaster();
        
        controller1.addEventListener('selectstart', () => {
            // Check for Button Hit
            const tempMatrix = new THREE.Matrix4().extractRotation(controller1.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

            const hits = raycaster.intersectObject(claimBtn);
            if(hits.length > 0) {
                handleDailyClaim();
            } else if (marker.visible) {
                cameraRig.position.set(marker.position.x, 0, marker.position.z);
            }
        });

        function handleDailyClaim() {
            const now = Date.now();
            if (now - stats.lastDaily < 86400000) {
                alert("Wait 24h for next reward!");
                return;
            }
            const reward = (Math.floor(Math.random() * 10) + 1) * 500;
            stats.chips += reward;
            stats.lastDaily = now;
            save();
            alert("Claimed: $" + reward);
        }

        // 7. MAIN LOOP
        let canTurn = true;
        renderer.setAnimationLoop(() => {
            const session = renderer.xr.getSession();
            if (session) {
                for (const source of session.inputSources) {
                    if (source.handedness === 'right' && source.gamepad) {
                        const axes = source.gamepad.axes;
                        if (Math.abs(axes[2]) > 0.8 && canTurn) {
                            cameraRig.rotation.y -= Math.sign(axes[2]) * (Math.PI/4);
                            canTurn = false; setTimeout(() => canTurn = true, 300);
                        }
                    }
                }
            }

            // Raycast for Teleport Marker
            const m = new THREE.Matrix4().makeRotationFromQuaternion(controller1.quaternion);
            const dir = new THREE.Vector3(0, 0, -1).applyMatrix4(m);
            if (dir.y < -0.1) {
                const ratio = -controller1.position.y / dir.y;
                marker.position.set(controller1.position.x + dir.x * ratio + cameraRig.position.x, 0.01, controller1.position.z + dir.z * ratio + cameraRig.position.z);
                marker.visible = true;
            } else { marker.visible = false; }

            renderer.render(scene, camera);
        });
    </script>
</body>
</html>
