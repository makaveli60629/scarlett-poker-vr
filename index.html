<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>POKER VR MASTER - 1.9.5</title>
    <style> 
        body { margin: 0; background-color: #000; overflow: hidden; font-family: Arial, sans-serif; }
        #vr-loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ffff; z-index: 10; font-weight: bold; }
    </style>
</head>
<body>
    <div id="vr-loading">LOADING GRAND LOBBY...</div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js';

        // 1. PERMANENT TRANSACTION DATA
        let stats = JSON.parse(localStorage.getItem('poker_master_save')) || { 
            chips: 500, rank: "Rookie", name: "Player 1", inventory: ["default_shirt"], lastClaim: 0 
        };
        
        const runTransaction = (amount, type) => {
            stats.chips += amount;
            localStorage.setItem('poker_master_save', JSON.stringify(stats));
            updateWatchUI();
        };

        // 2. SCENE & RENDERER SETUP
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020205);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const cameraRig = new THREE.Group();
        cameraRig.position.set(0, 0, 15); // Start back from the center
        cameraRig.add(camera);
        scene.add(cameraRig);
        scene.add(new THREE.HemisphereLight(0xffffff, 0x222222, 2.5));

        // 3. TEXTURE SYSTEM (assets/textures/)
        const texLoader = new THREE.TextureLoader();
        const path = 'assets/textures/';
        const tex = {
            brick: texLoader.load(path + 'brickwall.jpg'),
            carpet: texLoader.load(path + 'lobby_carpet.jpg'),
            felt: texLoader.load(path + 'table_felt_green.jpg'),
            logo: texLoader.load(path + 'brand_logo.jpg'),
            claim: texLoader.load(path + 'dailyclaim.jpg')
        };
        [tex.brick, tex.carpet].forEach(t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; });
        tex.brick.repeat.set(12, 3); tex.carpet.repeat.set(20, 20);

        // 4. ENVIRONMENT: THE GRAND HALL
        const lobbySize = 70;
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(lobbySize, lobbySize), new THREE.MeshStandardMaterial({ map: tex.carpet }));
        floor.rotation.x = -Math.PI/2; scene.add(floor);

        const wallObjects = [];
        for(let i=0; i<4; i++) {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(lobbySize, 15, 1.5), new THREE.MeshStandardMaterial({ map: tex.brick }));
            const angle = (Math.PI/2) * i;
            wall.position.set(Math.sin(angle)*(lobbySize/2), 7.5, Math.cos(angle)*(lobbySize/2));
            wall.rotation.y = angle;
            scene.add(wall); wallObjects.push(wall);
        }

        // Table
        const table = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 0.6, 32), new THREE.MeshStandardMaterial({ map: tex.felt }));
        table.position.set(0, 0.8, 0); scene.add(table);

        // 5. STATIONS (Locker, Store, Daily)
        function createTextLabel(text, size, color = "#00ffff") {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 128;
            ctx.fillStyle = color; ctx.font = "bold 60px Arial"; ctx.fillText(text, 20, 80);
            const t = new THREE.CanvasTexture(canvas);
            return new THREE.Mesh(new THREE.PlaneGeometry(size, size/4), new THREE.MeshBasicMaterial({map:t, transparent:true}));
        }

        const storeLabel = createTextLabel("MALL STORE", 6);
        storeLabel.position.set(20, 5, -20); storeLabel.rotation.y = -Math.PI/6;
        scene.add(storeLabel);

        const lockerLabel = createTextLabel("YOUR LOCKER", 6, "#ff00ff");
        lockerLabel.position.set(-20, 5, -20); lockerLabel.rotation.y = Math.PI/6;
        scene.add(lockerLabel);

        // 6. WRIST WATCH (LEFT HAND)
        const watchGroup = new THREE.Group();
        const watchCanvas = document.createElement('canvas');
        watchCanvas.width = 512; watchCanvas.height = 512;
        const wCtx = watchCanvas.getContext('2d');
        const watchTex = new THREE.CanvasTexture(watchCanvas);
        const watchMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.28, 0.28), new THREE.MeshBasicMaterial({ map: watchTex, transparent: true }));
        watchMesh.position.set(0, 0.06, 0.05); watchMesh.rotation.x = -Math.PI / 2;
        watchGroup.add(watchMesh); watchGroup.visible = false;

        function updateWatchUI() {
            wCtx.clearRect(0,0,512,512);
            wCtx.fillStyle = "rgba(0,0,0,0.95)"; wCtx.beginPath(); wCtx.roundRect(10,10,492,492,60); wCtx.fill();
            wCtx.strokeStyle = "#00ffff"; wCtx.lineWidth = 15; wCtx.stroke();
            wCtx.fillStyle = "#fff"; wCtx.font = "bold 50px Arial";
            wCtx.fillText(`$${stats.chips}`, 80, 180);
            wCtx.fillStyle = "#800080"; wCtx.roundRect(50, 350, 412, 100, 20); wCtx.fill();
            wCtx.fillStyle = "#fff"; wCtx.font = "bold 32px Arial";
            wCtx.fillText("RESET POSITION", 100, 415);
            watchTex.needsUpdate = true;
        }

        // 7. CONTROLS
        const controllerL = renderer.xr.getController(1);
        const laserL = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]), new THREE.LineBasicMaterial({color: 0x00ffcc}));
        laserL.scale.z = 100; controllerL.add(laserL, watchGroup); cameraRig.add(controllerL);

        const controllerR = renderer.xr.getController(0);
        cameraRig.add(controllerR);

        const marker = new THREE.Mesh(new THREE.RingGeometry(0.5, 0.6, 32), new THREE.MeshBasicMaterial({ color: 0x00ffcc }));
        marker.rotation.x = -Math.PI/2; scene.add(marker);

        let turnCooldown = false;
        const raycaster = new THREE.Raycaster();

        renderer.setAnimationLoop(() => {
            const loaderUI = document.getElementById('vr-loading');
            if(loaderUI) loaderUI.style.display = 'none';

            const session = renderer.xr.getSession();
            if (session) {
                for (const source of session.inputSources) {
                    const b = source.gamepad.buttons;
                    const a = source.gamepad.axes;

                    if (source.handedness === 'left') {
                        const m = new THREE.Matrix4().extractRotation(controllerL.matrixWorld);
                        raycaster.ray.origin.setFromMatrixPosition(controllerL.matrixWorld);
                        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(m);
                        const fHits = raycaster.intersectObject(floor);
                        if (fHits.length > 0) { marker.position.copy(fHits[0].point); marker.visible = true; }
                        
                        // LEFT TRIGGER MOVE
                        if (b[0].pressed && marker.visible) cameraRig.position.copy(marker.position);
                        // Y BUTTON MENU
                        if (b[5].pressed) { watchGroup.visible = true; updateWatchUI(); } else { watchGroup.visible = false; }
                        // RESET BUTTON (TRIGGER WHILE MENU OPEN)
                        if (watchGroup.visible && b[0].pressed) { cameraRig.position.set(0, 0, 12); cameraRig.rotation.y = 0; }
                    }
                    if (source.handedness === 'right' && Math.abs(a[2]) > 0.8 && !turnCooldown) {
                        cameraRig.rotation.y -= Math.sign(a[2]) * (Math.PI/4);
                        turnCooldown = true; setTimeout(() => turnCooldown = false, 300);
                    }
                }
            }
            renderer.render(scene, camera);
        });
    </script>
</body>
</html>
