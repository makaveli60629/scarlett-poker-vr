<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker Master 1.9.5 - True Hand Build</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #VRButton { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            padding: 15px 30px !important; background: #1a1a1a !important; color: #00ecff !important;
            border: 2px solid #00ecff !important; z-index: 1000; border-radius: 12px;
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let scene, camera, renderer, playerGroup;
        let hand1, hand2, teleportMarker, teleportLine, handMenu;
        let raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050515);

            playerGroup = new THREE.Group();
            playerGroup.position.set(0, 0, 7); 
            scene.add(playerGroup);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            playerGroup.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer, { 'optionalFeatures': ['hand-tracking'] }));

            const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 3);
            scene.add(ambient);

            buildSolidLobby();
            createStoreEntrance();
            createTeleportAssets();
            setupHands();

            renderer.setAnimationLoop(render);
        }

        function buildSolidLobby() {
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(60, 60), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            floor.rotation.x = -Math.PI / 2;
            floor.name = "Floor";
            scene.add(floor);

            const wallMat = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
            const configs = [
                { pos: [0, 2.5, -8], rot: 0 }, { pos: [0, 2.5, 8], rot: 0 },
                { pos: [-8, 2.5, 0], rot: Math.PI/2 }, { pos: [8, 2.5, 0], rot: Math.PI/2 }
            ];

            configs.forEach(cfg => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(16, 5, 0.2), wallMat);
                wall.position.set(...cfg.pos); wall.rotation.y = cfg.rot;
                scene.add(wall);
                const trim = new THREE.Mesh(new THREE.BoxGeometry(16.1, 0.2, 0.4), new THREE.MeshStandardMaterial({color: 0x000000}));
                trim.position.set(cfg.pos[0], 0.1, cfg.pos[2]); trim.rotation.y = cfg.rot;
                scene.add(trim);
            });

            const table = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0x004400 }));
            table.position.set(0, 0.8, 0);
            scene.add(table);
        }

        function createStoreEntrance() {
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.1, 3, 2), new THREE.MeshStandardMaterial({color: 0x000000}));
            frame.position.set(7.9, 1.5, 0);
            scene.add(frame);
            const neon = new THREE.Mesh(new THREE.PlaneGeometry(1, 0.3), new THREE.MeshBasicMaterial({color: 0xff00ff, transparent: true, opacity: 0.8}));
            neon.position.set(7.8, 3.2, 0); neon.rotation.y = -Math.PI/2;
            scene.add(neon);
        }

        function createTeleportAssets() {
            teleportMarker = new THREE.Group();
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.3, 0.03, 16, 32), new THREE.MeshBasicMaterial({color: 0x00ffcc}));
            ring.rotation.x = -Math.PI/2;
            teleportMarker.add(ring);
            teleportMarker.visible = false;
            scene.add(teleportMarker);

            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
            teleportLine = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({color: 0x00ffcc}));
            teleportLine.visible = false;
            scene.add(teleportLine);
        }

        function setupHands() {
            const hFactory = new XRHandModelFactory();
            // Complexion Material
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xd2b48c, roughness: 0.8 }); 

            hand1 = renderer.xr.getHand(0); // Right
            hand1.add(hFactory.createHandModel(hand1, "mesh"));
            playerGroup.add(hand1);

            hand2 = renderer.xr.getHand(1); // Left
            hand2.add(hFactory.createHandModel(hand2, "mesh"));
            playerGroup.add(hand2);

            // Menu Display (Starts hidden)
            const menuGeo = new THREE.PlaneGeometry(0.4, 0.3);
            const menuMat = new THREE.MeshBasicMaterial({ color: 0x001122, transparent: true, opacity: 0.9 });
            handMenu = new THREE.Mesh(menuGeo, menuMat);
            handMenu.position.set(0, 0.1, 0);
            handMenu.rotation.x = -Math.PI/2;
            handMenu.visible = false;
            hand2.add(handMenu);

            // Wrist Watch
            const watch = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.02, 0.06), new THREE.MeshStandardMaterial({color: 0x222222}));
            watch.position.set(0, 0.02, 0.05);
            hand2.add(watch);
        }

        function getPinchDist(hand) {
            if (!hand || !hand.joints) return 10;
            const thumb = hand.joints['thumb-tip'];
            const index = hand.joints['index-finger-tip'];
            if (thumb && index) return thumb.position.distanceTo(index.position);
            return 10;
        }

        function render() {
            // RIGHT HAND PINCH (Movement)
            if (getPinchDist(hand1) < 0.02) {
                tempMatrix.identity().extractRotation(hand1.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(hand1.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                const hits = raycaster.intersectObjects(scene.children);
                for (let hit of hits) {
                    if (hit.object.name === "Floor") {
                        teleportMarker.position.copy(hit.point);
                        teleportMarker.visible = true;
                        teleportLine.visible = true;
                        teleportLine.position.setFromMatrixPosition(hand1.matrixWorld);
                        teleportLine.lookAt(hit.point);
                        teleportLine.scale.z = hand1.position.distanceTo(hit.point);
                        break;
                    }
                }
            } else if (teleportMarker.visible) {
                playerGroup.position.set(teleportMarker.position.x, 0, teleportMarker.position.z);
                teleportMarker.visible = false; teleportLine.visible = false;
            }

            // LEFT HAND PINCH (Menu Toggle)
            if (getPinchDist(hand2) < 0.02) {
                handMenu.visible = true;
            } else {
                handMenu.visible = false;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
