<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>POKER VR - 2.1.21 PERMANENT FINAL</title>
    <style> body { margin: 0; background-color: #000; overflow: hidden; } </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js';

        // --- 1. MASTER BRAIN (DATA) ---
        const MASTER = {
            stats: JSON.parse(localStorage.getItem('poker_stats_v2')) || { chips: 15000, rank: "LEGEND" },
            save() { localStorage.setItem('poker_stats_v2', JSON.stringify(this.stats)); }
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x01020a);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const rig = new THREE.Group();
        rig.add(camera);
        scene.add(rig);

        const texLoader = new THREE.TextureLoader();
        const path = 'assets/textures/';
        const brick = texLoader.load(path + 'brickwall.jpg');
        const carpet = texLoader.load(path + 'lobby_carpet.jpg');
        const crownTex = texLoader.load(path + 'Crown.jpg');
        const watchTex = texLoader.load(path + 'watch_gold.jpg');
        [brick, carpet].forEach(t => { t.wrapS = t.wrapT = THREE.RepeatWrapping; t.repeat.set(10, 10); });

        // --- 2. ARCHITECTURE & STORE ---
        function createRoom(name, x, z, size, color, doors={n:false, s:false}) {
            const g = new THREE.Group(); g.position.set(x, 0, z);
            const f = new THREE.Mesh(new THREE.PlaneGeometry(size, size), new THREE.MeshStandardMaterial({map: carpet}));
            f.rotation.x = -Math.PI/2; f.userData.isFloor = true; g.add(f);
            
            const wallH = 15;
            [['n',0,-size/2,0], ['s',0,size/2,Math.PI], ['e',size/2,0,-Math.PI/2], ['w',-size/2,0,Math.PI/2]].forEach(p => {
                const wG = new THREE.Group();
                if(doors[p[0]]) {
                    const sw = (size-8)/2;
                    const l = new THREE.Mesh(new THREE.BoxGeometry(sw, wallH, 0.5), new THREE.MeshStandardMaterial({map: brick}));
                    l.position.x = -size/2 + sw/2;
                    const r = new THREE.Mesh(new THREE.BoxGeometry(sw, wallH, 0.5), new THREE.MeshStandardMaterial({map: brick}));
                    r.position.x = size/2 - sw/2;
                    wG.add(l, r);
                    [l, r].forEach(m => { m.userData.isWall = true; });
                } else {
                    const solid = new THREE.Mesh(new THREE.BoxGeometry(size, wallH, 0.5), new THREE.MeshStandardMaterial({map: brick}));
                    solid.userData.isWall = true; wG.add(solid);
                }
                wG.position.set(p[1], wallH/2, p[2]); wG.rotation.y = p[3]; g.add(wG);
            });
            scene.add(g); return g;
        }

        const lobby = createRoom("Lobby", 0, 0, 50, 0x00ffff, {n:true, s:true});
        const store = createRoom("Store", 0, 80, 40, 0x00ff00, {n:true});
        const poker = createRoom("Poker", 0, -80, 40, 0xff00ff, {s:true});

        // Store Pedestals & Assets
        const items = [crownTex, watchTex, crownTex]; // Assets for display
        items.forEach((tex, i) => {
            const ped = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 1, 16), new THREE.MeshStandardMaterial({color: 0x222222}));
            ped.position.set(-6 + (i*6), 0.5, 90);
            const display = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({map: tex}));
            display.position.y = 1; ped.add(display);
            scene.add(ped);
        });

        // --- 3. SLEEK WRIST HUD ---
        const conL = renderer.xr.getController(1);
        const conR = renderer.xr.getController(0);
        rig.add(conL, conR);

        const wrist = new THREE.Group();
        wrist.visible = false; 
        wrist.position.set(0.02, 0.05, 0); 
        wrist.rotation.x = -Math.PI/2;
        conL.add(wrist);

        const menuCanvas = document.createElement('canvas'); menuCanvas.width = 256; menuCanvas.height = 256;
        const ctx = menuCanvas.getContext('2d');
        const menuTex = new THREE.CanvasTexture(menuCanvas);
        const menuMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 0.12), new THREE.MeshBasicMaterial({map: menuTex, transparent: true}));
        wrist.add(menuMesh);

        function updateHUD() {
            ctx.clearRect(0,0,256,256);
            ctx.fillStyle = "rgba(0,10,20,0.95)"; ctx.roundRect(0,0,256,256, 20); ctx.fill();
            ctx.strokeStyle = "cyan"; ctx.lineWidth = 5; ctx.strokeRect(5,5,246,246);
            ctx.fillStyle = "white"; ctx.font = "bold 24px Arial"; ctx.fillText(`$${MASTER.stats.chips}`, 30, 60);
            ctx.font = "16px Arial"; ctx.fillText(MASTER.stats.rank, 30, 95);
            ctx.fillStyle = "cyan"; ctx.fillText(new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}), 30, 130);
            menuTex.needsUpdate = true;
        }

        // --- 4. CONTROL SYSTEMS ---
        const marker = new THREE.Mesh(new THREE.RingGeometry(0.3, 0.4, 32), new THREE.MeshBasicMaterial({color: 0x00ffff, side: THREE.DoubleSide}));
        marker.rotation.x = -Math.PI/2; scene.add(marker);
        const laserL = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]), new THREE.LineBasicMaterial({color: 0x00ffff}));
        conL.add(laserL);

        const rayL = new THREE.
