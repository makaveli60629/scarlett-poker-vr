<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker VR Master 1.9.0 - Unified Permanent Build</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #VRButton { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            padding: 15px 30px !important; background: #111 !important; color: #00ffcc !important;
            border: 2px solid #00ffcc !important; z-index: 1000; border-radius: 12px; font-weight: bold;
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let scene, camera, renderer, playerGroup;
        let hand1, hand2;
        let teleportMarker, teleportLine;
        let raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050515); // Deep Midnight

            playerGroup = new THREE.Group();
            playerGroup.position.set(0, 0, 7); // Start away from table
            scene.add(playerGroup);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            playerGroup.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer, { 'optionalFeatures': ['hand-tracking'] }));

            const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 3);
            scene.add(ambient);

            buildSolidLobby();
            createDailyPickZone();
            createTeleportAssets();
            setupHands();

            renderer.setAnimationLoop(render);
        }

        function buildSolidLobby() {
            // FLOOR
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            floor.rotation.x = -Math.PI / 2;
            floor.name = "Floor";
            scene.add(floor);

            // ALL 4 WALLS (Sealed)
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
            const wallH = 5;
            const wallW = 15;
            
            const wallConfigs = [
                { pos: [0, 2.5, -7.5], rot: 0 },         // Back
                { pos: [0, 2.5, 7.5], rot: 0 },          // Front
                { pos: [-7.5, 2.5, 0], rot: Math.PI/2 }, // Left
                { pos: [7.5, 2.5, 0], rot: Math.PI/2 }   // Right
            ];

            wallConfigs.forEach(cfg => {
                const wall = new THREE.Mesh(new THREE.BoxGeometry(wallW, wallH, 0.3), wallMat);
                wall.position.set(...cfg.pos);
                wall.rotation.y = cfg.rot;
                scene.add(wall);

                // BOTTOM TRIM FOR EVERY WALL
                const trim = new THREE.Mesh(new THREE.BoxGeometry(wallW + 0.1, 0.2, 0.4), new THREE.MeshStandardMaterial({color: 0x000000}));
                trim.position.set(cfg.pos[0], 0.1, cfg.pos[2]);
                trim.rotation.y = cfg.rot;
                scene.add(trim);
            });

            // MAIN TABLE
            const table = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0x004400 }));
            table.position.set(0, 0.8, 0);
            scene.add(table);

            // CHIPS (7 Types)
            const chipColors = [0xffffff, 0xff0000, 0x0000ff, 0x00ff00, 0x000000, 0x800080, 0xFFD700];
            chipColors.forEach((c, i) => {
                const stack = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.02, 16), new THREE.MeshStandardMaterial({color: c}));
                stack.position.set(-0.4 + (i * 0.12), 0.91, 0.1);
                scene.add(stack);
            });
        }

        function createDailyPickZone() {
            const dailyTable = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 0.1, 32, 1, false, 0, Math.PI), new THREE.MeshStandardMaterial({color: 0x002266}));
            dailyTable.position.set(-4, 0.8, -4);
            dailyTable.rotation.y = Math.PI;
            scene.add(dailyTable);

            // DAILY PICK HOLOGRAM
            const holo = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.4), new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5, side: THREE.DoubleSide }));
            holo.position.set(-4, 1.5, -4);
            scene.add(holo);
        }

        function createTeleportAssets() {
            const marker = new THREE.Group();
            const ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.02, 16, 32), new THREE.MeshBasicMaterial({color: 0x00ffcc}));
            const ring2 = new THREE.Mesh(new THREE.TorusGeometry(0.35, 0.01, 16, 32), new THREE.MeshBasicMaterial({color: 0x00ffcc}));
            ring1.rotation.x = ring2.rotation.x = -Math.PI/2;
            marker.add(ring1, ring2);
            teleportMarker = marker;
            teleportMarker.visible = false;
            scene.add(teleportMarker);

            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
            teleportLine = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({color: 0x00ffcc}));
            teleportLine.visible = false;
            scene.add(teleportLine);
        }

        function setupHands() {
            const hFactory = new XRHandModelFactory();
            hand1 = renderer.xr.getHand(0); // Right
            hand1.add(hFactory.createHandModel(hand1, "mesh"));
            playerGroup.add(hand1);

            hand2 = renderer.xr.getHand(1); // Left
            hand2.add(hFactory.createHandModel(hand2, "mesh"));
            playerGroup.add(hand2);

            // WRIST WATCH ON LEFT
            const watch = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.02, 0.05), new THREE.MeshStandardMaterial({color:0x222222}));
            watch.position.set(0, 0.02, 0.04);
            hand2.add(watch);
        }

        function isPinching(hand) {
            if (!hand || !hand.joints) return false;
            const thumb = hand.joints['thumb-tip'];
            const index = hand.joints['index-finger-tip'];
            if (thumb && index) return thumb.position.distanceTo(index.position) < 0.015;
            return false;
        }

        function render() {
            // RIGHT HAND PINCH TELEPORT
            if (isPinching(hand1)) {
                tempMatrix.identity().extractRotation(hand1.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(hand1.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                
                const intersects = raycaster.intersectObjects(scene.children);
                for (let hit of intersects) {
                    if (hit.object.name === "Floor") {
                        teleportMarker.position.copy(hit.point);
                        teleportMarker.visible = true;
                        teleportLine.visible = true;
                        teleportLine.position.setFromMatrixPosition(hand1.matrixWorld);
                        teleportLine.lookAt(hit.point);
                        teleportLine.scale.z = hand1.position.distanceTo(hit.point);
                        break;
                    }
                }
            } else if (teleportMarker.visible) {
                // JUMP ON RELEASE
                playerGroup.position.set(teleportMarker.position.x, 0, teleportMarker.position.z);
                teleportMarker.visible = false;
                teleportLine.visible = false;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
