<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poker VR 1.8.8 - Daily Pick & Hand Jump</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #VRButton { 
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            padding: 15px 30px !important; background: #1a1a1a !important; color: #00ecff !important;
            border: 2px solid #00ecff !important; z-index: 1000; border-radius: 10px; font-weight: bold;
        }
    </style>
</head>
<body>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

        let scene, camera, renderer, playerGroup;
        let hand1, hand2;
        let teleportMarker, teleportLine;
        let raycaster = new THREE.Raycaster();
        const tempMatrix = new THREE.Matrix4();

        // Game Logic State
        const dailyPickState = {
            lastPickTime: null,
            available: true
        };

        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a); // Deep Night Blue
            
            playerGroup = new THREE.Group();
            playerGroup.position.set(0, 0, 8); // Spawn further back in the bigger room
            scene.add(playerGroup);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            playerGroup.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer, { 'optionalFeatures': ['hand-tracking'] }));

            const ambient = new THREE.HemisphereLight(0xffffff, 0x444444, 2.5);
            scene.add(ambient);

            buildEnlargedRoom();
            createDailyPickTable();
            createTeleportAssets();
            setupHands();

            renderer.setAnimationLoop(render);
        }

        function buildEnlargedRoom() {
            // FLOOR (Expanded to 100x100)
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x151515 }));
            floor.rotation.x = -Math.PI / 2;
            floor.name = "Floor";
            scene.add(floor);

            // 4 WALLS (Larger perimeter)
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x660000 });
            const box = new THREE.BoxGeometry(30, 6, 0.5);
            
            const back = new THREE.Mesh(box, wallMat); back.position.set(0, 3, -15);
            const left = new THREE.Mesh(box, wallMat); left.position.set(-15, 3, 0); left.rotation.y = Math.PI/2;
            const right = new THREE.Mesh(box, wallMat); right.position.set(15, 3, 0); right.rotation.y = Math.PI/2;
            scene.add(back, left, right);

            // TRIMS
            const trimMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
            const tGeo = new THREE.BoxGeometry(30.2, 0.2, 0.4);
            const bTrim = new THREE.Mesh(tGeo, trimMat); bTrim.position.set(0, 0.1, -14.8);
            scene.add(bTrim);
        }

        function createDailyPickTable() {
            // Small Blackjack-style Table
            const tableGroup = new THREE.Group();
            tableGroup.position.set(-4, 0, -5);
            scene.add(tableGroup);

            const topGeo = new THREE.CylinderGeometry(1, 1, 0.1, 32, 1, false, 0, Math.PI); // Semi-circle
            const topMat = new THREE.MeshStandardMaterial({ color: 0x003366 }); // Blue for Daily Pick
            const tableTop = new THREE.Mesh(topGeo, topMat);
            tableTop.position.y = 0.9;
            tableTop.rotation.y = Math.PI;
            tableGroup.add(tableTop);

            // Add 5 Choice Buttons
            const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff];
            const increments = ["$500", "$1000", "$1500", "$2000", "$2500"];
            
            for(let i=0; i<5; i++) {
                const btn = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.05, 0.15),
                    new THREE.MeshStandardMaterial({ color: colors[i] })
                );
                btn.position.set(-0.6 + (i * 0.3), 0.95, -0.2);
                btn.name = "Pick_" + increments[i];
                tableGroup.add(btn);
            }
        }

        function createTeleportAssets() {
            teleportMarker = new THREE.Mesh(new THREE.TorusGeometry(0.4, 0.04, 16, 32), new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
            teleportMarker.rotation.x = -Math.PI/2;
            teleportMarker.visible = false;
            scene.add(teleportMarker);

            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
            teleportLine = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x00ff00 }));
            teleportLine.visible = false;
            scene.add(teleportLine);
        }

        function setupHands() {
            const hFactory = new XRHandModelFactory();
            hand1 = renderer.xr.getHand(0); // Right
            hand1.add(hFactory.createHandModel(hand1, "mesh"));
            playerGroup.add(hand1);

            hand2 = renderer.xr.getHand(1); // Left
            hand2.add(hFactory.createHandModel(hand2, "mesh"));
            playerGroup.add(hand2);
        }

        function isPinching(hand) {
            if (!hand || !hand.joints) return false;
            const thumb = hand.joints['thumb-tip'];
            const index = hand.joints['index-finger-tip'];
            if (thumb && index) {
                return thumb.position.distanceTo(index.position) < 0.015;
            }
            return false;
        }

        function render() {
            // Right Hand Teleport Logic
            if (isPinching(hand1)) {
                tempMatrix.identity().extractRotation(hand1.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(hand1.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                const hits = raycaster.intersectObjects(scene.children);
                for (let hit of hits) {
                    if (hit.object.name === "Floor") {
                        teleportMarker.position.copy(hit.point);
                        teleportMarker.visible = true;
                        teleportLine.visible = true;
                        teleportLine.position.setFromMatrixPosition(hand1.matrixWorld);
                        teleportLine.lookAt(hit.point);
                        teleportLine.scale.z = hand1.position.distanceTo(hit.point);
                        break;
                    }
                }
            } else if (teleportMarker.visible) {
                // Execute Jump
                playerGroup.position.set(teleportMarker.position.x, 0, teleportMarker.position.z);
                teleportMarker.visible = false;
                teleportLine.visible = false;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
