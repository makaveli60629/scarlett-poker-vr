<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Poker VR 1.3 - Grand Lobby Master</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        #gui {
            position: fixed; top: 20px; left: 20px; color: #00f2ff;
            font-size: 24px; text-shadow: 2px 2px #000; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="gui">WALLET: $<span id="wallet">5000</span></div>

    <script type="importmap">
        { "imports": { 
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" 
        } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- 1. THE PHYSICS ENGINE ---
        class PhysicsEngine {
            constructor() { this.colliders = []; }
            add(mesh) { this.colliders.push(new THREE.Box3().setFromObject(mesh)); }
            check(pos) {
                const playerBox = new THREE.Box3().setFromCenterAndSize(pos, new THREE.Vector3(0.6, 2, 0.6));
                return this.colliders.some(c => c.intersectsBox(playerBox));
            }
        }
        const P = new PhysicsEngine();

        // --- 2. SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const playerRig = new THREE.Group();
        playerRig.add(camera);
        scene.add(playerRig);
        playerRig.position.set(0, 0, 10); // Spawn in Lobby center

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));

        // --- 3. MATERIALS ---
        const brickMat = new THREE.MeshStandardMaterial({ color: 0x8b2222 }); 
        const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.1 });
        const glassMat = new THREE.MeshStandardMaterial({ color: 0x00f2ff, transparent: true, opacity: 0.3 });

        // --- 4. THE GRAND LOBBY (4m Height) ---
        const lobbySize = 30;
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(lobbySize, lobbySize), new THREE.MeshStandardMaterial({color: 0x111111}));
        floor.rotation.x = -Math.PI/2;
        scene.add(floor);

        const ceil = new THREE.Mesh(new THREE.PlaneGeometry(lobbySize, lobbySize), new THREE.MeshStandardMaterial({color: 0x0a0a0a}));
        ceil.position.y = 4;
        ceil.rotation.x = Math.PI/2;
        scene.add(ceil);

        // Solid Outer Walls
        const createWall = (x, z, w, rot) => {
            const wall = new THREE.Mesh(new THREE.BoxGeometry(w, 4, 0.5), brickMat);
            wall.position.set(x, 2, z);
            wall.rotation.y = rot;
            scene.add(wall);
            P.add(wall);
        };
        createWall(0, -15, 30, 0); // Back
        createWall(-15, 0, 30, Math.PI/2); // Left
        createWall(15, 0, 30, Math.PI/2); // Right

        // Brand Logo Placement
        const loader = new THREE.TextureLoader();
        loader.load('logo.png', (tex) => {
            const logo = new THREE.Mesh(new THREE.PlaneGeometry(4, 2), new THREE.MeshBasicMaterial({map: tex, transparent: true}));
            logo.position.set(0, 2.5, -14.7);
            scene.add(logo);
        });

        // --- 5. THE THREE TELEPORTS (Holograms) ---
        function createPortal(x, z, color, label, targetPos) {
            const portal = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.1, 32), glassMat);
            portal.position.set(x, 0.05, z);
            scene.add(portal);

            const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 4, 32), 
                new THREE.MeshStandardMaterial({color: color, transparent: true, opacity: 0.2, emissive: color}));
            beam.position.set(x, 2, z);
            scene.add(beam);

            // Logic: If player steps on portal
            portal.userData = { isPortal: true, target: targetPos };
        }

        createPortal(-8, -5, 0x00ff00, "POKER", new THREE.Vector3(50, 0, 0));
        createPortal(8, -5, 0xff00ff, "STORE", new THREE.Vector3(-50, 0, 0));
        createPortal(0, -8, 0xffd700, "VAULT", new THREE.Vector3(0, 0, -50));

        // --- 6. DAILY REWARD TABLE ---
        const table = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), goldMat);
        table.position.set(0, 0.5, 5);
        scene.add(table);
        P.add(table);

        const rewardButton = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshStandardMaterial({color: 0x00f2ff}));
        rewardButton.position.set(0, 1.1, 5);
        scene.add(rewardButton);

        let wallet = 5000;
        function claimReward() {
            wallet += 500;
            document.getElementById('wallet').innerText = wallet;
            rewardButton.material.color.set(0x555555); // Disable
            setTimeout(() => rewardButton.material.color.set(0x00f2ff), 86400000); // 24h
        }

        // --- 7. CONTROLS ---
        const modelFactory = new XRControllerModelFactory();
        const cRight = renderer.xr.getController(0);
        cRight.addEventListener('selectstart', () => {
            // Check for reward claim
            const dist = camera.position.distanceTo(rewardButton.position);
            if(dist < 2) claimReward();
        });
        playerRig.add(cRight);
        const gRight = renderer.xr.getControllerGrip(0);
        gRight.add(modelFactory.createControllerModel(gRight));
        playerRig.add(gRight);

        // Movement Loop
        function update() {
            const session = renderer.xr.getSession();
            if (session) {
                for (const source of session.inputSources) {
                    if (source.gamepad && source.handedness === 'left') {
                        const axes = source.gamepad.axes;
                        const dir = new THREE.Vector3(axes[2], 0, axes[3]).applyQuaternion(camera.quaternion);
                        dir.y = 0;
                        const next = playerRig.position.clone().addScaledVector(dir, 0.1);
                        if (!P.check(next)) playerRig.position.copy(next);
                    }
                }
            }
        }

        renderer.setAnimationLoop(() => {
            update();
            renderer.render(scene, camera);
        });
    </script>
</body>
</html>
