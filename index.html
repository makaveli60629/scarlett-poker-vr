<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VR Poker - Neon Executive Suite</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        #canvas-container { width: 100vw; height: 100vh; }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        let scene, camera, renderer, userGroup;
        let raycaster, tempMatrix = new THREE.Matrix4();
        let teleportTarget = null, teleportMarker;
        const controllers = [];
        
        init();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x020205);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            userGroup = new THREE.Group();
            userGroup.position.set(0, 0, 2); 
            scene.add(userGroup);
            userGroup.add(camera);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            document.body.appendChild(VRButton.createButton(renderer));

            // LIGHTING
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);
            const tableLight = new THREE.PointLight(0x00ffff, 2, 10);
            tableLight.position.set(0, 3, 0);
            scene.add(tableLight);

            // INPUT: HANDS + CONTROLLERS
            const handModelFactory = new XRHandModelFactory();
            const controllerModelFactory = new XRControllerModelFactory();

            for (let i = 0; i < 2; i++) {
                // Hand Setup
                const hand = renderer.xr.getHand(i);
                hand.add(handModelFactory.createHandModel(hand, "mesh"));
                scene.add(hand);

                // Controller Setup
                const controller = renderer.xr.getController(i);
                controller.addEventListener('selectstart', onSelectStart);
                controller.addEventListener('selectend', onSelectEnd);
                scene.add(controller);
                
                const model = controllerModelFactory.createControllerModel(controller);
                controller.add(model);
                controllers.push(controller);

                // Teleport Ray Visual
                const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
                const line = new THREE.Line(lineGeo);
                line.name = 'line';
                line.scale.z = 5;
                controller.add(line);
            }

            // TELEPORT MARKER (The Jumping Glow)
            const markerGeo = new THREE.RingGeometry(0.15, 0.2, 32);
            const markerMat = new THREE.MeshBasicMaterial({ color: 0x00ffcc, side: THREE.DoubleSide });
            teleportMarker = new THREE.Mesh(markerGeo, markerMat);
            teleportMarker.rotation.x = -Math.PI / 2;
            teleportMarker.visible = false;
            scene.add(teleportMarker);

            raycaster = new THREE.Raycaster();

            // WORLD ASSETS
            createNeonRoom();
            createProfessionalTable();
            createFloatingUI();

            renderer.setAnimationLoop(render);
        }

        function createNeonRoom() {
            // All 4 Walls with Neon Trims
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x050505 });
            const neonMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });

            const wallData = [
                { pos: [0, 2.5, -5], rot: [0, 0, 0] },     // North
                { pos: [0, 2.5, 5], rot: [0, Math.PI, 0] }, // South
                { pos: [5, 2.5, 0], rot: [0, -Math.PI/2, 0] }, // East
                { pos: [-5, 2.5, 0], rot: [0, Math.PI/2, 0] }  // West
            ];

            wallData.forEach(data => {
                const wall = new THREE.Mesh(new THREE.PlaneGeometry(10, 5), wallMat);
                wall.position.set(...data.pos);
                wall.rotation.set(...data.rot);
                scene.add(wall);

                // Neon Trim Line
                const trim = new THREE.Mesh(new THREE.BoxGeometry(10, 0.05, 0.05), neonMat);
                trim.position.set(data.pos[0], 4.8, data.pos[2]);
                trim.rotation.set(...data.rot);
                scene.add(trim);
            });

            // Floor Grid
            const grid = new THREE.GridHelper(20, 20, 0xff00ff, 0x222222);
            scene.add(grid);
        }

        function createProfessionalTable() {
            const tableGroup = new THREE.Group();
            
            // 1. Felt Oval
            const felt = new THREE.Mesh(
                new THREE.CylinderGeometry(1, 1, 0.1, 64),
                new THREE.MeshStandardMaterial({ color: 0x076324 })
            );
            felt.scale.set(2, 1, 1.2);
            felt.position.y = 0.95;
            tableGroup.add(felt);

            // 2. Leather Trim (The Bumper)
            const trim = new THREE.Mesh(
                new THREE.TorusGeometry(1, 0.08, 16, 100),
                new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.5 })
            );
            trim.rotation.x = Math.PI / 2;
            trim.scale.set(2, 1.2, 1);
            trim.position.y = 1.02;
            tableGroup.add(trim);

            scene.add(tableGroup);
        }

        function createFloatingUI() {
            // Hovering Leaderboard
            const board = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 2),
                new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.8 })
            );
            board.position.set(-3, 2, -4);
            scene.add(board);

            // Store Interface
            const store = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 2),
                new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.8 })
            );
            store.position.set(3, 2, -4);
            scene.add(store);
        }

        function onSelectStart(event) {
            this.userData.isSelecting = true;
        }

        function onSelectEnd(event) {
            this.userData.isSelecting = false;
            if (teleportMarker.visible) {
                userGroup.position.set(teleportTarget.x, 0, teleportTarget.z);
            }
        }

        function render() {
            // Handle Teleportation Logic
            teleportMarker.visible = false;
            controllers.forEach(controller => {
                if (controller.userData.isSelecting) {
                    tempMatrix.identity().extractRotation(controller.matrixWorld);
                    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

                    const intersects = raycaster.intersectObjects(scene.children);
                    if (intersects.length > 0) {
                        const hit = intersects[0];
                        if (hit.object instanceof THREE.GridHelper || hit.point.y < 0.1) {
                            teleportTarget = hit.point;
                            teleportMarker.position.copy(teleportTarget);
                            teleportMarker.visible = true;
                        }
                    }
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
