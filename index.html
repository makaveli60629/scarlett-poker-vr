<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Poker VR 1.4 - The Scorpion Update</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #VRButton { bottom: 20px !important; background: #00f2ff !important; color: #000 !important; }
        #gui { position: fixed; top: 20px; left: 20px; color: #00f2ff; font-size: 24px; z-index: 100; }
        #win-popup { position: fixed; top: 20%; left: 50%; transform: translate(-50%, -50%); 
                   background: rgba(0,0,0,0.9); color: gold; padding: 40px; border: 4px solid gold; 
                   border-radius: 20px; display: none; text-align: center; font-size: 2em; z-index: 200; }
    </style>
</head>
<body>
    <div id="gui">CASH: $<span id="balance">5000</span></div>
    <div id="win-popup"><h1 id="win-txt">WINNER</h1><p id="win-hand"></p></div>

    <script type="importmap">
        { "imports": { 
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" 
        } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { VRButton } from 'three/addons/webxr/VRButton.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- 1. CORE ENGINE ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const playerRig = new THREE.Group();
        playerRig.add(camera);
        scene.add(playerRig);
        playerRig.position.set(0, 0, 0);

        // --- 2. THE 4M HOLLOW BOX ROOMS ---
        const wallMat = new THREE.MeshStandardMaterial({ color: 0x8b2222, side: THREE.BackSide });
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const floors = [];

        function createRoom(x, z, size, name) {
            const group = new THREE.Group();
            const box = new THREE.Mesh(new THREE.BoxGeometry(size, 4, size), wallMat);
            box.position.y = 2;
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(size, size), floorMat);
            floor.rotation.x = -Math.PI/2;
            floor.name = name;
            floors.push(floor);
            group.add(box, floor);
            group.position.set(x, 0, z);
            scene.add(group);
            return group;
        }

        const lobby = createRoom(0, 0, 20, "lobby");
        const pokerRoom = createRoom(25, 0, 15, "poker");
        const storeRoom = createRoom(-25, 0, 15, "store");

        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const sun = new THREE.PointLight(0x00f2ff, 2, 20);
        sun.position.set(0, 3.8, 0);
        scene.add(sun);

        // --- 3. SCORPION POKER & BOT ---
        const table = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 0.2, 32), new THREE.MeshStandardMaterial({color: 0x076324}));
        table.position.set(25, 0.8, 0);
        scene.add(table);

        // The Dealer Bot (Low-poly Avatar)
        const bot = new THREE.Group();
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshStandardMaterial({color: 0xffdbac}));
        head.position.y = 1.6;
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.8, 0.3), new THREE.MeshStandardMaterial({color: 0x222222}));
        body.position.y = 1.0;
        bot.add(head, body);
        bot.position.set(25, 0, -1.5);
        bot.lookAt(25, 0, 0);
        scene.add(bot);

        // --- 4. CARD SYSTEM ---
        const deck = [];
        const cardGeo = new THREE.PlaneGeometry(0.15, 0.22);
        function dealCard(x, z, delay) {
            setTimeout(() => {
                const card = new THREE.Mesh(cardGeo, new THREE.MeshStandardMaterial({color: 0xffffff, side: THREE.DoubleSide}));
                card.position.set(25, 0.85, 0);
                card.rotation.x = Math.PI/2;
                scene.add(card);
                // Animate to position
                new THREE.Vector3(x, 0.85, z); 
                card.position.set(x, 0.86, z);
            }, delay);
        }

        // --- 5. PERMANENT CONTROLS (LEAP & POINT) ---
        const marker = new THREE.Mesh(new THREE.RingGeometry(0.2, 0.25, 32), new THREE.MeshBasicMaterial({color: 0x00ff00, side: THREE.DoubleSide}));
        marker.rotation.x = -Math.PI/2;
        marker.visible = false;
        scene.add(marker);

        const raycaster = new THREE.Raycaster();
        const tempMat = new THREE.Matrix4();
        let intersectPoint = null;

        const c0 = renderer.xr.getController(0); // Right
        c0.addEventListener('selectstart', () => {
            if (marker.visible && intersectPoint) {
                playerRig.position.set(intersectPoint.x, 0, intersectPoint.z);
                // Trigger deal if leaping to poker table
                if (playerRig.position.distanceTo(new THREE.Vector3(25,0,0)) < 3) {
                    dealCard(24.5, 0.5, 100); dealCard(25.5, 0.5, 300); // Deal 2 cards
                }
            }
        });

        const factory = new XRControllerModelFactory();
        [0, 1].forEach(id => {
            const c = renderer.xr.getController(id);
            const g = renderer.xr.getControllerGrip(id);
            g.add(factory.createControllerModel(g));
            const laser = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]), new THREE.LineBasicMaterial({color: 0x00f2ff}));
            c.add(laser);
            playerRig.add(c, g);
        });

        // --- 6. RENDER LOOP ---
        renderer.setAnimationLoop(() => {
            tempMat.identity().extractRotation(c0.matrixWorld);
            raycaster.ray.origin.setFromMatrixPosition(c0.matrixWorld);
            raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMat);

            const hits = raycaster.intersectObjects(floors);
            if (hits.length > 0) {
                intersectPoint = hits[0].point;
                marker.position.copy(intersectPoint);
                marker.position.y = 0.05; marker.visible = true;
            } else { marker.visible = false; }

            renderer.render(scene, camera);
        });
    </script>
</body>
</html>
