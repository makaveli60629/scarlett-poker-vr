<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>POKER VR - 2.1.5 PERMANENT FINAL</title>
    <style> body { margin: 0; background-color: #000; overflow: hidden; } </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js';

        // 1. DATA & PERSISTENCE
        let stats = JSON.parse(localStorage.getItem('poker_master_save')) || { 
            chips: 500, rank: "ROOKIE", name: "Player 1", wallet: 500 
        };
        const save = () => localStorage.setItem('poker_master_save', JSON.stringify(stats));

        // 2. SCENE & LIGHTING
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050508);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const cameraRig = new THREE.Group();
        cameraRig.position.set(0, 0, 10);
        cameraRig.add(camera);
        scene.add(cameraRig);
        scene.add(new THREE.AmbientLight(0xffffff, 1.0), new THREE.DirectionalLight(0xffffff, 2));

        // 3. ENVIRONMENT
        const texLoader = new THREE.TextureLoader();
        const carpet = texLoader.load('assets/textures/lobby_carpet.jpg');
        carpet.wrapS = carpet.wrapT = THREE.RepeatWrapping; carpet.repeat.set(20,20);
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(70, 70), new THREE.MeshStandardMaterial({map: carpet}));
        floor.rotation.x = -Math.PI/2; scene.add(floor);

        const table = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 0.8, 32), new THREE.MeshStandardMaterial({color: 0x004400}));
        table.position.y = 0.4; scene.add(table);

        // Hologram Gates
        const createGate = (x, z, color, label) => {
            const gate = new THREE.Group();
            gate.add(new THREE.Mesh(new THREE.TorusGeometry(2, 0.05, 16, 100), new THREE.MeshBasicMaterial({color})));
            gate.children[0].rotation.x = Math.PI/2;
            gate.position.set(x, 0.1, z); scene.add(gate); return gate;
        };
        const storeGate = createGate(-20, -20, 0x00ffff);
        const gameGate = createGate(20, -20, 0xff00ff);

        // 4. THE WRIST WATCH & MENU (Left Wrist)
        const watchGroup = new THREE.Group();
        const watchCanvas = document.createElement('canvas'); watchCanvas.width = 256; watchCanvas.height = 256;
        const wCtx = watchCanvas.getContext('2d');
        const watchTex = new THREE.CanvasTexture(watchCanvas);
        const watchMesh = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 0.2), new THREE.MeshBasicMaterial({map: watchTex, transparent: true}));
        watchMesh.position.set(0, 0.05, 0); watchMesh.rotation.x = -Math.PI/2;
        watchGroup.add(watchMesh);
        watchGroup.visible = false; // Toggled by Menu Button

        function updateWatch() {
            wCtx.clearRect(0,0,256,256);
            wCtx.fillStyle = "rgba(0,0,0,0.8)"; wCtx.fillRect(0,0,256,256);
            wCtx.strokeStyle = "#00ffff"; wCtx.lineWidth = 10; wCtx.strokeRect(5,5,246,246);
            wCtx.fillStyle = "#fff"; wCtx.font = "24px Arial";
            wCtx.fillText(`$${stats.chips}`, 50, 50);
            wCtx.fillText(stats.rank, 50, 90);
            wCtx.fillStyle = "#ff0000"; wCtx.fillRect(40, 150, 180, 50);
            wCtx.fillStyle = "#fff"; wCtx.fillText("RETURN LOBBY", 50, 185);
            watchTex.needsUpdate = true;
        }

        // 5. CONTROLS (Oculus Mapping)
        const controllerL = renderer.xr.getController(1);
        const controllerR = renderer.xr.getController(0);
        controllerL.add(watchGroup); // Watch stays on left wrist
        
        const laser = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]), new THREE.LineBasicMaterial({color: 0x00ffff}));
        laser.scale.z = 10; controllerL.add(laser); // Laser on Left
        cameraRig.add(controllerL, controllerR);

        const leapMarker = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.5, 32), new THREE.MeshBasicMaterial({color: 0x00ffff}));
        leapMarker.rotation.x = -Math.PI/2; scene.add(leapMarker);

        const raycaster = new THREE.Raycaster();
        let turnCooldown = false;

        renderer.setAnimationLoop(() => {
            updateWatch();
            const session = renderer.xr.getSession();
            if (session) {
                for (const source of session.inputSources) {
                    const b = source.gamepad.buttons;
                    const a = source.gamepad.axes;

                    // LEFT HAND: Movement & Menu
                    if (source.handedness === 'left') {
                        const m = new THREE.Matrix4().extractRotation(controllerL.matrixWorld);
                        raycaster.ray.origin.setFromMatrixPosition(controllerL.matrixWorld);
                        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(m);
                        const hits = raycaster.intersectObject(floor);
                        if (hits.length > 0) {
                            leapMarker.position.copy(hits[0].point); leapMarker.visible = true;
                            if (b[0].pressed) cameraRig.position.copy(hits[0].point); // Trigger Teleport
                        }
                        // Menu Button (The "White" Button / Y button / Menu button)
                        if (b[4].pressed || b[5].pressed) { watchGroup.visible = !watchGroup.visible; }
                    }

                    // RIGHT HAND: Snap Turn & Actions
                    if (source.handedness === 'right') {
                        const sX = a[2] || a[3] || 0;
                        if (!turnCooldown && Math.abs(sX) > 0.7) {
                            cameraRig.rotation.y -= Math.sign(sX) * (Math.PI/4);
                            turnCooldown = true; setTimeout(() => turnCooldown = false, 300);
                        }
                        // Right Trigger (Execute Menu / Return to Lobby)
                        if (b[0].pressed && watchGroup.visible) {
                            cameraRig.position.set(0, 0, 10); // Reset to spawn
                            watchGroup.visible = false;
                        }
                    }
                }
            }
            renderer.render(scene, camera);
        });
    </script>
</body>
</html>
